{"mappings":"AAAA,0BAA0B;AAC1B,gDAAgD;AAEhD,6CAA6C;AAC7C,eAAe;AACf,2DAA2D;AAE3D,6DAA6D;AAE7D,gCAAgC;AAChC,yBAAyB;AAEzB,mDAAmD;AACnD,0BAA0B;AAE1B,4CAA4C;AAC5C,kBAAkB;AAClB,sBAAsB;AACtB,uBAAuB;AACvB,wBAAwB;AACxB,cAAc;AACd,0BAA0B;AAE1B,WAAW;AACX,4CAA4C;AAC5C,8BAA8B;AAE9B,aAAa;AACb,8CAA8C;AAE9C,eAAe;AACf,+CAA+C;AAC/C,iBAAiB;AACjB,qBAAqB;AACrB,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAE5C,UAAU;AACV,MAAM,IAAI,OAAO,YAAY;AAC7B,QAAQ,IAAI","sources":["src/main.js"],"sourcesContent":["// // window.jQuery是一个全局函数\n// const api = jQuery('.test'); //不返回元素们，返回api对象\n\n// // 链式操作，由于addClass返回的是api本身，我们可以继续addClass\n// // this就是api\n// api.addClass('red').addClass('blue');//遍历所有刚才获取的元素，添加red\n\n// const x1 = jQuery('.test').find('.child').addClass('red');\n\n// const api1 = jQuery('.test');\n// api1.addClass('blue');\n\n// const api2 = api1.find('child').addClass('red');\n// api1.addClass('green');\n\n// 测试back函数，我们需要返回上级到test并添加yellow到className\n// jQuery('.test')\n//     .find('.child')\n//     .addClass('red')\n//     .addClass('blue')\n//     .back()\n//     .addClass('yellow')\n\n// 测试each函数\n// const x = jQuery('.test').find('.child');\n// x.each((n)=>console.log(n))\n\n// 测试parent函数\n// const x = jQuery('.test').parent().print();\n\n// 测试children函数\n// const x = jQuery('.test').children().print()\n//测试previous和next\n// console.log('测试');\n// const x = jQuery('.test').next().print();\n// const y = jQuery('.test').prev().print();\n// const z = jQuery('.next').next().print();\n\n// 测试index\nconst x = jQuery('.current').index();\nconsole.log(x)"],"names":[],"version":3,"file":"index.de158e3a.js.map","sourceRoot":"/__parcel_source_root/"}